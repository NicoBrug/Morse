/*****************************************************************//**
 * Generated by Morse IDL to UE Translator.
 * @file   ROSDynamicArrayPrimitives.h
 * @brief  File containing data structures and the definition of the message generated from the IDL.
 *         Idl Type : ROSDynamicArrayPrimitives.idl
 *         
 * @author Nicolas B.
 * @date   December 2023
 * @copyright Copyright 2023 Nicolas Brugie. All rights reserved.
 *********************************************************************/

#pragma once 
#include "CoreMinimal.h" 
#include "Topic/TopicProxy.h"


#include "DataImplementation/DynamicArrayPrimitives.h"
#include "Utils/MRSConvertUtils.h"

#include "IDLDynamicArrayPrimitives.generated.h" 







/** @addtogroup {NameDoxygenMessageContainer}
  * @brief {NameDoxygenMessageContainer}
  *
  * @{
  */
USTRUCT(Blueprintable)
struct FIDLDynamicArrayPrimitives
{
    GENERATED_BODY()

public:
    /**
    * @cond
    */
    FIDLDynamicArrayPrimitives()
    {

    };
    /**
     * @endcond
     */

    
    UPROPERTY(EditAnywhere)
    TArray<bool> BoolValues;
    
    UPROPERTY(EditAnywhere)
    TArray<uint8> ByteValues;
    
    UPROPERTY(EditAnywhere)
    TArray<uint8> CharValues;
    
    UPROPERTY(EditAnywhere)
    TArray<float> Float32Values;
    
    UPROPERTY(EditAnywhere)
    TArray<double> Float64Values;
    
    UPROPERTY(EditAnywhere)
    TArray<int8> Int8Values;
    
    UPROPERTY(EditAnywhere)
    TArray<uint8> Uint8Values;
    
    UPROPERTY(EditAnywhere)
    TArray<int16> Int16Values;
    
    UPROPERTY(EditAnywhere)
    TArray<uint16> Uint16Values;
    
    UPROPERTY(EditAnywhere)
    TArray<int32> Int32Values;
    
    UPROPERTY(EditAnywhere)
    TArray<unsigned int> Uint32Values;
    
    UPROPERTY(EditAnywhere)
    TArray<int64> Int64Values;
    
    UPROPERTY(EditAnywhere)
    TArray<uint64> Uint64Values;
    
    UPROPERTY(EditAnywhere)
    TArray<FString> StringValues;
    
    UPROPERTY(EditAnywhere)
    int32 Check;
    

    /**
     * @cond
     */
    void DDSToUE (const test_msgs_msg_DynamicArrayPrimitives& InData) 
    {
        UMRSConvertUtils::SequenceToTArray<bool, bool>(InData.bool_values._buffer, BoolValues, InData.bool_values._length);
        UMRSConvertUtils::SequenceToTArray<uint8, uint8>(InData.byte_values._buffer, ByteValues, InData.byte_values._length);
        UMRSConvertUtils::SequenceToTArray<char, unsigned char>(InData.char_values._buffer, CharValues, InData.char_values._length);
        UMRSConvertUtils::SequenceToTArray<float, float>(InData.float32_values._buffer, Float32Values, InData.float32_values._length);
        UMRSConvertUtils::SequenceToTArray<double, double>(InData.float64_values._buffer, Float64Values, InData.float64_values._length);
        UMRSConvertUtils::SequenceToTArray<uint8, int8>(InData.int8_values._buffer, Int8Values, InData.int8_values._length);
        UMRSConvertUtils::SequenceToTArray<uint8, uint8>(InData.uint8_values._buffer, Uint8Values, InData.uint8_values._length);
        UMRSConvertUtils::SequenceToTArray<int16, int16>(InData.int16_values._buffer, Int16Values, InData.int16_values._length);
        UMRSConvertUtils::SequenceToTArray<uint16, uint16>(InData.uint16_values._buffer, Uint16Values, InData.uint16_values._length);
        UMRSConvertUtils::SequenceToTArray<int32, int32>(InData.int32_values._buffer, Int32Values, InData.int32_values._length);
        UMRSConvertUtils::SequenceToTArray<uint32, unsigned int>(InData.uint32_values._buffer, Uint32Values, InData.uint32_values._length);
        UMRSConvertUtils::SequenceToTArray<int64, int64>(InData.int64_values._buffer, Int64Values, InData.int64_values._length);
        UMRSConvertUtils::SequenceToTArray<uint64, uint64>(InData.uint64_values._buffer, Uint64Values, InData.uint64_values._length);
        UMRSConvertUtils::StrSequenceToTArray<char*, FString>(InData.string_values._buffer, StringValues, InData.string_values._length);
        Check = InData.check;
    };

    void UEToDDS (test_msgs_msg_DynamicArrayPrimitives& OutData) 
    {
        OutData.bool_values._length = BoolValues.Num();
        OutData.bool_values._buffer = dds_sequence_bool_allocbuf(BoolValues.Num());
        OutData.bool_values._release = true;
        UMRSConvertUtils::TArrayToSequence<bool, bool>(BoolValues, OutData.bool_values._buffer, BoolValues.Num());
        OutData.byte_values._length = ByteValues.Num();
        OutData.byte_values._buffer = dds_sequence_octet_allocbuf(ByteValues.Num());
        OutData.byte_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint8, uint8>(ByteValues, OutData.byte_values._buffer, ByteValues.Num());
        OutData.char_values._length = CharValues.Num();
        OutData.char_values._buffer = dds_sequence_char_allocbuf(CharValues.Num());
        OutData.char_values._release = true;
        UMRSConvertUtils::TArrayToSequence<char, unsigned char>(CharValues, OutData.char_values._buffer, CharValues.Num());
        OutData.float32_values._length = Float32Values.Num();
        OutData.float32_values._buffer = dds_sequence_float_allocbuf(Float32Values.Num());
        OutData.float32_values._release = true;
        UMRSConvertUtils::TArrayToSequence<float, float>(Float32Values, OutData.float32_values._buffer, Float32Values.Num());
        OutData.float64_values._length = Float64Values.Num();
        OutData.float64_values._buffer = dds_sequence_double_allocbuf(Float64Values.Num());
        OutData.float64_values._release = true;
        UMRSConvertUtils::TArrayToSequence<double, double>(Float64Values, OutData.float64_values._buffer, Float64Values.Num());
        OutData.int8_values._length = Int8Values.Num();
        OutData.int8_values._buffer = dds_sequence_octet_allocbuf(Int8Values.Num());
        OutData.int8_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint8, int8>(Int8Values, OutData.int8_values._buffer, Int8Values.Num());
        OutData.uint8_values._length = Uint8Values.Num();
        OutData.uint8_values._buffer = dds_sequence_octet_allocbuf(Uint8Values.Num());
        OutData.uint8_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint8, uint8>(Uint8Values, OutData.uint8_values._buffer, Uint8Values.Num());
        OutData.int16_values._length = Int16Values.Num();
        OutData.int16_values._buffer = dds_sequence_short_allocbuf(Int16Values.Num());
        OutData.int16_values._release = true;
        UMRSConvertUtils::TArrayToSequence<int16, int16>(Int16Values, OutData.int16_values._buffer, Int16Values.Num());
        OutData.uint16_values._length = Uint16Values.Num();
        OutData.uint16_values._buffer = dds_sequence_unsigned_short_allocbuf(Uint16Values.Num());
        OutData.uint16_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint16, uint16>(Uint16Values, OutData.uint16_values._buffer, Uint16Values.Num());
        OutData.int32_values._length = Int32Values.Num();
        OutData.int32_values._buffer = dds_sequence_long_allocbuf(Int32Values.Num());
        OutData.int32_values._release = true;
        UMRSConvertUtils::TArrayToSequence<int32, int32>(Int32Values, OutData.int32_values._buffer, Int32Values.Num());
        OutData.uint32_values._length = Uint32Values.Num();
        OutData.uint32_values._buffer = dds_sequence_unsigned_long_allocbuf(Uint32Values.Num());
        OutData.uint32_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint32, unsigned int>(Uint32Values, OutData.uint32_values._buffer, Uint32Values.Num());
        OutData.int64_values._length = Int64Values.Num();
        OutData.int64_values._buffer = dds_sequence_long_long_allocbuf(Int64Values.Num());
        OutData.int64_values._release = true;
        UMRSConvertUtils::TArrayToSequence<int64, int64>(Int64Values, OutData.int64_values._buffer, Int64Values.Num());
        OutData.uint64_values._length = Uint64Values.Num();
        OutData.uint64_values._buffer = dds_sequence_unsigned_long_long_allocbuf(Uint64Values.Num());
        OutData.uint64_values._release = true;
        UMRSConvertUtils::TArrayToSequence<uint64, uint64>(Uint64Values, OutData.uint64_values._buffer, Uint64Values.Num());
        OutData.string_values._length = StringValues.Num();
        OutData.string_values._buffer = dds_sequence_string_allocbuf(StringValues.Num());
        OutData.string_values._release = true;
        UMRSConvertUtils::StrTArrayToSequence<char*, FString>(StringValues, OutData.string_values._buffer, StringValues.Num());
        OutData.check = Check;
    };
    
    /**
     * @endcond
     */
};
/** @} */



DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FROSDynamicArrayPrimitivesCallback, const FIDLDynamicArrayPrimitives, Data);

UCLASS(BlueprintType, Blueprintable)
class MORSETEST_API UDynamicArrayPrimitives_TopicProxy : public UTopicProxy
{
    GENERATED_BODY()

public:

    UPROPERTY(BlueprintAssignable)
    FROSDynamicArrayPrimitivesCallback OnDataChanged;

    virtual void Initialize() override {
        Data = test_msgs_msg_DynamicArrayPrimitives__alloc();
    };

    virtual void Terminate() override {
        test_msgs_msg_DynamicArrayPrimitives_free(Data, DDS_FREE_ALL);
    };

    UFUNCTION(BlueprintCallable)
    void GetData(FIDLDynamicArrayPrimitives& Output)
    {
        Output.DDSToUE(*Data);
    };

    UFUNCTION(BlueprintCallable)
    void SetData(FIDLDynamicArrayPrimitives Input)
    {
        Input.UEToDDS(*Data);
    };

    virtual void ExecuteMessageCallback() override
    {
        FIDLDynamicArrayPrimitives NewData;
        NewData.DDSToUE(*Data);
        OnDataChanged.Broadcast(NewData);
    };

    virtual void* Get() override
    {
        return Data;
    };

    virtual const dds_topic_descriptor_t* GetTypeDesc() override
    {
        return &test_msgs_msg_DynamicArrayPrimitives_desc;
    };

private:
    test_msgs_msg_DynamicArrayPrimitives* Data;
};